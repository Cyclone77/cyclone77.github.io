{
  "articles": [
    {
      "id": 3784306353,
      "number": 2,
      "title": "学会图片懒加载",
      "description": "在现代网页中，高清图片往往占据了流量的“大头”。如果用户打开页面时一次性加载所有图片，不仅会消耗大量带宽，还会导致首屏加载缓慢（LCP 指标变差）。",
      "content": "在现代网页中，高清图片往往占据了流量的“大头”。如果用户打开页面时一次性加载所有图片，不仅会消耗大量带宽，还会导致首屏加载缓慢（LCP 指标变差）。\n\n**懒加载 (Lazy Loading)** 的核心思想很简单：**只有当图片进入（或即将进入）用户的视口区域时，才去加载它**。\n\n## 🛠️ 1. 实现方案对比\n\n实现懒加载主要有以下两种主流方式，我们将重点介绍现代浏览器的原生方案和 JS API 方案。\n\n| 方案 | 兼容性 | 复杂度 | 推荐场景 |\n| :--- | :--- | :--- | :--- |\n| **原生属性 `loading=\"lazy\"`** | 现代浏览器很好 (Chrome 76+) | ⭐ | 简单页面，无需精细控制 |\n| **Intersection Observer API** | 极好 (需 Polyfill 支持 IE) | ⭐⭐⭐ | 需要精确控制加载时机、动画等 |\n\n\n## 💻 2. 方案一：原生 HTML 属性 (最简单)\n\n这是浏览器原生支持的特性，甚至不需要写一行 JavaScript 代码。\n\n### 2.1 代码示例\n\n只需要给 `img` 标签添加 `loading=\"lazy\"` 属性即可。\n\n```html\n<div class=\"gallery\">\n    <img src=\"[https://example.com/photo.jpg](https://example.com/photo.jpg)\" \n         alt=\"风景照\" \n         loading=\"lazy\" \n         width=\"600\" \n         height=\"400\">\n    \n    <p>向下滚动查看更多...</p>\n    \n    <img src=\"[https://example.com/photo-2.jpg](https://example.com/photo-2.jpg)\" \n         alt=\"另一张风景照\" \n         loading=\"lazy\">\n</div>\n\n```\n\n> **注意**：必须为图片指定 `width` 和 `height` 属性（或通过 CSS 设定宽高比例），以防止图片加载后造成页面布局抖动 (CLS)。\n\n\n## ⚙️ 3. 方案二：使用 Intersection Observer API (最可控)\n\n当我们需要更复杂的交互（比如图片出现时添加淡入动画，或者处理背景图懒加载）时，原生属性就不够用了。这时我们需要使用 **Intersection Observer (交叉观察器)**。\n\n### 3.1 HTML 准备\n\n我们将真实的图片地址放在 `data-src` 属性中，`src` 放一张很小的占位图。\n\n```html\n<img class=\"lazy-img\" \n     src=\"placeholder.jpg\" \n     data-src=\"[https://example.com/real-image-1.jpg](https://example.com/real-image-1.jpg)\" \n     alt=\"动态加载图片\">\n\n<img class=\"lazy-img\" \n     src=\"placeholder.jpg\" \n     data-src=\"[https://example.com/real-image-2.jpg](https://example.com/real-image-2.jpg)\" \n     alt=\"动态加载图片\">\n\n```\n\n### 3.2 JavaScript 逻辑\n\n这段代码会监听图片是否进入视口，一旦进入，就将 `data-src` 替换为 `src`。\n\n```javascript\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n    // 1. 获取所有需要懒加载的图片\n    const lazyImages = document.querySelectorAll('.lazy-img');\n\n    // 2. 检查浏览器是否支持该 API\n    if ('IntersectionObserver' in window) {\n        \n        const imageObserver = new IntersectionObserver((entries, observer) => {\n            entries.forEach(entry => {\n                // 如果元素进入视口 (isIntersecting 为 true)\n                if (entry.isIntersecting) {\n                    const img = entry.target;\n                    \n                    // 替换真实图片地址\n                    img.src = img.dataset.src;\n                    \n                    // 可选：添加一个类名来触发 CSS 过渡动画\n                    img.classList.add('fade-in');\n                    \n                    // 图片加载后，停止观察该元素\n                    observer.unobserve(img);\n                }\n            });\n        });\n\n        // 3. 开始观察每一个图片元素\n        lazyImages.forEach(img => {\n            imageObserver.observe(img);\n        });\n    } else {\n        // Fallback: 如果浏览器不支持，可以在这里写降级处理（直接加载）\n    }\n});\n\n```\n\n### 3.3 配合 CSS 动画\n\n为了让体验更丝滑，我们可以加上简单的淡入效果：\n\n```css\n.lazy-img {\n    opacity: 0;\n    transition: opacity 0.5s ease-in;\n}\n\n.lazy-img.fade-in {\n    opacity: 1;\n}\n\n```\n\n\n## 📊 4. 效果验证\n\n你可以打开 Chrome 开发者工具 (F12) -> **Network** 面板 -> 选择 **Img** 过滤器。\n\n当你向下滚动页面时，你会发现图片请求是随着滚动逐个发送的，而不是在刷新页面时瞬间全部加载。这就是懒加载生效了！\n\n\n## 🎉 5. 总结\n\n* 对于大多数静态内容页面，直接使用 `<img loading=\"lazy\">` 是性价比最高的选择。\n* 如果需要处理背景图、实现淡入特效或兼容老旧浏览器，**Intersection Observer** 是目前业界标准的解决方案。\n\n希望这个技巧能帮你把网站的首屏加载速度提升 50% 以上！",
      "author": {
        "name": "Cyclone77",
        "avatar": "https://avatars.githubusercontent.com/u/10395760?v=4",
        "url": "https://github.com/Cyclone77"
      },
      "status": "已发布",
      "categories": [
        "前端开发",
        "HTML",
        "JAVASCRIPT"
      ],
      "tags": [],
      "displays": [
        "置顶",
        "热门",
        "精选"
      ],
      "coverImage": "",
      "readTime": "11 分钟阅读",
      "date": "2026年1月6日",
      "createdAt": "2026-01-06T08:55:01Z",
      "updatedAt": "2026-01-07T08:02:10Z",
      "commentsCount": 0,
      "url": "https://github.com/Cyclone77/cyclone77.github.io/issues/2"
    },
    {
      "id": 3787486231,
      "number": 3,
      "title": "深入浅出 React 性能优化：useMemo 与 useCallback 实战指南",
      "description": "在 React 开发中，随着应用规模的增长，性能问题往往不期而至。很多时候，组件的过度渲染（Re-render）是导致页面卡顿的“元凶”。",
      "content": "在 React 开发中，随着应用规模的增长，性能问题往往不期而至。很多时候，组件的过度渲染（Re-render）是导致页面卡顿的“元凶”。\n\n今天我们通过实战代码，深入探讨 React Hooks 中两个强大的优化工具：`useMemo` 和 `useCallback`，看看它们是如何帮助我们驯服组件渲染的。\n\n\n## 🧐 1. 识别问题：什么是无意义的渲染？\n\n在优化之前，我们需要先理解 React 的默认行为。当父组件更新时，默认情况下，它的所有子组件都会重新渲染，无论子组件的 Props 是否发生了变化。\n\n### 1.1 性能瓶颈模拟\n\n假设我们有一个包含大量数据计算的组件。\n\n```javascript\n// ❌ 优化前的代码：每次 count 变化，expensiveCalculation 都会重新执行\nimport React, { useState } from 'react';\n\nconst expensiveCalculation = (num) => {\n  console.log('正在进行昂贵的计算...');\n  for (let i = 0; i < 1000000000; i++) {} // 模拟耗时操作\n  return num * 2;\n};\n\nconst App = () => {\n  const [count, setCount] = useState(0);\n  const [input, setInput] = useState('');\n\n  // 问题所在：即使我们只是在输入框打字（改变 input），\n  // 导致 App 重渲染，这个耗时函数也会被再次执行，造成卡顿。\n  const calculation = expensiveCalculation(count);\n\n  return (\n    <div>\n      <input \n        value={input} \n        onChange={(e) => setInput(e.target.value)} \n        placeholder=\"输入内容...\" \n      />\n      <p>昂贵的计算结果: {calculation}</p>\n      <button onClick={() => setCount(count + 1)}>增加 Count</button>\n    </div>\n  );\n};\n\n```\n\n### 1.2 问题分析\n\n在上面的代码中，`input` 状态的改变会导致 `App` 组件重新渲染。因为 `expensiveCalculation` 是直接调用的，所以每次打字时，主线程都会被阻塞，导致页面明显卡顿。\n\n\n\n## 🧠 2. 使用 useMemo 缓存计算结果\n\n`useMemo` 的作用是**缓存计算结果**。只有当依赖项发生变化时，它才会重新计算，否则直接返回上一次缓存的值。\n\n### 2.1 优化方案\n\n我们将使用 `useMemo` 包裹那个耗时的函数调用。\n\n```javascript\n// ✅ 优化后的代码：只有 count 变化时，才会重新计算\nimport React, { useState, useMemo } from 'react';\n\nconst App = () => {\n  const [count, setCount] = useState(0);\n  const [input, setInput] = useState('');\n\n  // 1. 使用 useMemo 包裹\n  const calculation = useMemo(() => {\n    return expensiveCalculation(count);\n  }, [count]); // 2. 指定依赖项：仅当 count 变化时执行\n\n  return (\n    <div>\n      <input \n        value={input} \n        onChange={(e) => setInput(e.target.value)} \n      />\n      <p>计算结果: {calculation}</p>\n      <button onClick={() => setCount(count + 1)}>增加 Count</button>\n    </div>\n  );\n};\n\n```\n\n### 2.2 效果\n\n现在，当你在输入框中打字时，`expensiveCalculation` 不会执行，页面极其流畅。只有点击按钮改变 `count` 时，计算才会发生。\n\n\n\n## 📞 3. 使用 useCallback 缓存函数引用\n\n`useMemo` 缓存的是**值**，而 `useCallback` 缓存的是**函数引用**。这在向子组件传递回调函数时尤为重要。\n\n### 3.1 引用相等性陷阱\n\n在 JavaScript 中，每次组件重新渲染，组件内部定义的函数都会被重新创建。这意味着 `function() {} !== function() {}`。\n\n如果我们将这个函数作为 props 传递给经过 `React.memo` 优化的子组件，由于引用变了，子组件依然会重新渲染。\n\n### 3.2 实战代码：配合 React.memo\n\n```javascript\nimport React, { useState, useCallback } from 'react';\n\n// 一个被 memo 保护的子组件\nconst ChildButton = React.memo(({ onClick, label }) => {\n  console.log(`${label} 渲染了`);\n  return <button onClick={onClick}>{label}</button>;\n});\n\nconst Parent = () => {\n  const [count, setCount] = useState(0);\n  const [text, setText] = useState('');\n\n  // ❌ 错误示范：没有使用 useCallback\n  // 每次 Parent 渲染（例如输入 text），handleClick 都是新的引用\n  // 导致 ChildButton 认为 props 变了，从而强制重渲染\n  const handleIncrementNormal = () => {\n    setCount((c) => c + 1);\n  };\n\n  // ✅ 正确示范：使用 useCallback\n  // 依赖项为空数组，意味着这个函数引用永远不会变\n  const handleIncrementMemo = useCallback(() => {\n    setCount((c) => c + 1);\n  }, []);\n\n  return (\n    <div>\n      <input value={text} onChange={e => setText(e.target.value)} />\n      <p>Count: {count}</p>\n      \n      {/* 输入文字时，这个按钮会无意义地重新渲染 */}\n      <ChildButton onClick={handleIncrementNormal} label=\"普通按钮\" />\n      \n      {/* 输入文字时，这个按钮不会重新渲染 */}\n      <ChildButton onClick={handleIncrementMemo} label=\"优化按钮\" />\n    </div>\n  );\n};\n\n```\n\n\n## ⚖️ 4. 总结与最佳实践\n\n优化虽然好，但不要滥用。`useMemo` and `useCallback` 本身也有开销（分配内存、依赖检查）。\n\n### 4.1 何时**不**应该使用？\n\n1. **简单的计算**：如果只是简单的字符串拼接或基本数学运算，直接写在渲染逻辑里即可，使用 Hook 反而增加了代码复杂度。\n2. **非 memo 的子组件**：如果子组件没有使用 `React.memo` 包裹，给它传递 `useCallback` 没有任何性能收益。\n\n### 4.2 核心原则\n\n1. **优先定位瓶颈**：不要预先优化（Premature Optimization）。先用 React DevTools 的 Profiler 找出哪里慢，再动手。\n2. **组合使用**：`useCallback` 通常需要配合 `React.memo` 才能发挥最大威力。\n3. **保持依赖清晰**：始终在依赖数组中如实填写所有依赖项，避免闭包陷阱（Stale Closure）。",
      "author": {
        "name": "Cyclone77",
        "avatar": "https://avatars.githubusercontent.com/u/10395760?v=4",
        "url": "https://github.com/Cyclone77"
      },
      "status": "已发布",
      "categories": [
        "前端开发",
        "REACT"
      ],
      "tags": [],
      "displays": [],
      "coverImage": "https://github.com/user-attachments/assets/bd30839b-1cab-43a4-95c7-d8d36c208710",
      "readTime": "13 分钟阅读",
      "date": "2026年1月7日",
      "createdAt": "2026-01-07T06:09:37Z",
      "updatedAt": "2026-01-07T09:47:37Z",
      "commentsCount": 0,
      "url": "https://github.com/Cyclone77/cyclone77.github.io/issues/3"
    },
    {
      "id": 3783903379,
      "number": 1,
      "title": "利用 CSS 变量实现网站“暗黑模式”",
      "description": "在现代 Web 开发中，暗黑模式已不再是“锦上添花”的功能，而是提升用户体验的标配。它能有效减轻用户的视觉疲劳，尤其是在夜间浏览时。",
      "content": "在现代 Web 开发中，**暗黑模式**已不再是“锦上添花”的功能，而是提升用户体验的标配。它能有效减轻用户的视觉疲劳，尤其是在夜间浏览时。\n\n今天，我们将摒弃复杂的预处理器，仅使用原生 **CSS 变量 (Custom Properties)** 和少量的 **JavaScript**，构建一个轻量级且高性能的主题切换功能。\n\n---\n\n## 💡 1. 核心原理\n\n在开始写代码之前，我们需要理解核心思路。我们将不再硬编码颜色（如 `#ffffff` 或 `#000000`），而是使用 CSS 变量作为“占位符”。\n\n1. **定义变量**：在 `:root` 中定义一套默认（亮色）的语义化变量。\n2. **覆盖变量**：通过给 `<html>` 标签添加属性（如 `data-theme=\"dark\"`），在其中重新定义同一套变量的值。\n3. **一键切换**：JavaScript 只需要负责切换这个属性即可，样式会自动由浏览器重绘。\n\n---\n\n## 🛠️ 2. 开发步骤\n\n下面我们将通过三个步骤由浅入深地实现该功能。\n\n### 2.1 编写 HTML 结构\n\n我们需要一个简单的页面结构和一个用于触发切换的按钮。\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>暗黑模式示例</title>\n</head>\n<body>\n    <div class=\"container\">\n        <header>\n            <h1>前端技术博客</h1>\n            <button id=\"theme-toggle\" aria-label=\"切换主题\">🌞/🌜</button>\n        </header>\n\n        <main>\n            <div class=\"card\">\n                <h2>为什么选择 CSS 变量？</h2>\n                <p>CSS 变量具有动态性，可以在运行时修改，这是预处理器（Sass/Less）无法做到的。</p>\n            </div>\n        </main>\n    </div>\n</body>\n</html>\n\n```\n\n### 2.2 配置 CSS 变量体系\n\n这是最关键的一步。我们将使用语义化的命名（如 `--bg-primary` 而不是 `--white`），这样代码更具可维护性。\n\n```css\n/* 1. 定义默认主题（亮色模式） */\n:root {\n    --bg-primary: #ffffff;\n    --bg-secondary: #f4f4f5;\n    --text-primary: #18181b;\n    --text-secondary: #71717a;\n    --accent-color: #3b82f6;\n    --card-border: #e4e4e7;\n}\n\n/* 2. 定义暗黑模式（通过 data-theme 属性触发） */\n[data-theme=\"dark\"] {\n    --bg-primary: #18181b;\n    --bg-secondary: #000000;\n    --text-primary: #f4f4f5;\n    --text-secondary: #a1a1aa;\n    --accent-color: #60a5fa;\n    --card-border: #27272a;\n}\n\n/* 3. 应用变量到元素 */\nbody {\n    background-color: var(--bg-secondary);\n    color: var(--text-primary);\n    transition: background-color 0.3s, color 0.3s; /* 添加平滑过渡 */\n}\n\n.card {\n    background-color: var(--bg-primary);\n    border: 1px solid var(--card-border);\n    padding: 2rem;\n    border-radius: 8px;\n}\n\nbutton {\n    background-color: var(--accent-color);\n    color: white;\n    border: none;\n    padding: 0.5rem 1rem;\n    border-radius: 4px;\n    cursor: pointer;\n}\n\n```\n\n### 2.3 添加 JavaScript 交互逻辑\n\n最后，我们需要用 JS 来监听点击事件，并切换 `html` 标签上的属性。\n\n```javascript\nconst toggleBtn = document.getElementById('theme-toggle');\nconst html = document.documentElement;\n\ntoggleBtn.addEventListener('click', () => {\n    // 获取当前的主题属性\n    const currentTheme = html.getAttribute('data-theme');\n    \n    // 判断并切换\n    if (currentTheme === 'dark') {\n        html.setAttribute('data-theme', 'light');\n    } else {\n        html.setAttribute('data-theme', 'dark');\n    }\n});\n\n```\n\n---\n\n## 🚀 3. 进阶优化：记住用户的选择\n\n上面的代码虽然能工作，但刷新页面后会重置。为了提供最佳体验，我们需要将用户的偏好保存在 `localStorage` 中。\n\n1. **保存状态**：每次切换时写入 LocalStorage。\n2. **初始化检查**：页面加载时读取配置。\n\n优化后的 JavaScript 代码如下：\n\n```javascript\n// 1. 初始化逻辑：检查本地存储\nconst savedTheme = localStorage.getItem('theme');\n// 如果之前存过 'dark'，则直接应用\nif (savedTheme === 'dark') {\n    document.documentElement.setAttribute('data-theme', 'dark');\n}\n\n// 2. 切换逻辑\nconst toggleBtn = document.getElementById('theme-toggle');\n\ntoggleBtn.addEventListener('click', () => {\n    const html = document.documentElement;\n    const currentTheme = html.getAttribute('data-theme');\n    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';\n\n    // 更新 DOM\n    html.setAttribute('data-theme', newTheme);\n    \n    // 更新本地存储\n    localStorage.setItem('theme', newTheme);\n});\n\n```\n\n---\n\n## 🎉 4. 总结\n\n通过以上步骤，我们没有引入任何笨重的第三方库，仅用几十行代码就实现了高性能的暗黑模式。\n\n**这种方案的优势在于：**\n\n* **性能好**：浏览器原生渲染，无 JS 计算样式开销。\n* **维护方便**：只需要在一个地方（CSS）管理颜色。\n* **兼容性**：现代浏览器均完美支持 CSS 变量。",
      "author": {
        "name": "Cyclone77",
        "avatar": "https://avatars.githubusercontent.com/u/10395760?v=4",
        "url": "https://github.com/Cyclone77"
      },
      "status": "已发布",
      "categories": [
        "前端开发",
        "CSS"
      ],
      "tags": [],
      "displays": [
        "热门"
      ],
      "coverImage": "",
      "readTime": "12 分钟阅读",
      "date": "2026年1月6日",
      "createdAt": "2026-01-06T06:19:24Z",
      "updatedAt": "2026-01-07T06:24:28Z",
      "commentsCount": 0,
      "url": "https://github.com/Cyclone77/cyclone77.github.io/issues/1"
    }
  ],
  "total": 3,
  "lastUpdate": "2026-01-07T09:47:47.574Z"
}