name: Sync Articles

on:
    issues:
        types: [edited, unlabeled] # opened 和 labeled 交给 Guard 任务处理后触发
    workflow_run:
        workflows: ['Issue Label Manager']
        types:
            - completed
    workflow_dispatch:
        inputs:
            full_sync:
                description: '执行全量文章同步'
                required: false
                type: boolean
                default: false

# 防止并发执行，避免 git push 冲突
concurrency:
    group: articles-sync
    cancel-in-progress: false # 不取消正在运行的任务，而是排队等待

jobs:
    sync-articles:
        runs-on: ubuntu-latest
        # 如果是 workflow_run 触发，要求上游必须成功
        if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
        permissions:
            contents: write
            issues: read

        steps:
            - name: Checkout code
              uses: actions/checkout@v4

            - name: Create data directory
              run: mkdir -p public/data

            - name: Check if sync is needed
              id: check_sync
              if: github.event_name == 'issues'
              uses: actions/github-script@v7
              with:
                  script: |
                      const issueNumber = context.payload.issue?.number;
                      if (!issueNumber) {
                        core.setOutput('should_sync', 'true');
                        return;
                      }

                      const issue = await github.rest.issues.get({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issueNumber
                      });

                      const labels = issue.data.labels.map(l => l.name);
                      const hasPublishedLabel = labels.some(l => l === '状态:已发布');

                      // 如果是标签变更，需要同步（无论当前状态）
                      // 如果是内容编辑，只有已发布状态才同步
                      const isLabelChange = context.payload.action === 'labeled' || context.payload.action === 'unlabeled';
                      const shouldSync = isLabelChange || hasPublishedLabel;

                      core.setOutput('should_sync', shouldSync ? 'true' : 'false');
                      console.log(`Issue #${issueNumber} 同步检查: ${shouldSync ? '需要同步' : '跳过同步'} (action: ${context.payload.action}, 已发布: ${hasPublishedLabel})`);

            - name: Sync articles
              if: github.event_name != 'issues' || steps.check_sync.outputs.should_sync == 'true'
              uses: actions/github-script@v7
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              with:
                  script: |
                      const fs = require('fs');
                      const path = require('path');

                      const dataDir = path.join(process.cwd(), 'public', 'data');
                      const articlesFile = path.join(dataDir, 'articles.json');

                      // 判断是否为全量同步
                      const isFullSync = context.payload.inputs?.full_sync === 'true' || !fs.existsSync(articlesFile);

                      // 辅助函数：解析标签
                      function parseLabels(labels) {
                        const labelNames = labels.map(l => l.name);
                        console.log('解析标签列表:', labelNames.join(', '));
                        const statusLabel = labelNames.find(l => l === '状态:已发布' || l === '已发布');
                        return {
                          status: statusLabel ? '已发布' : (labelNames.find(l => l.startsWith('状态:'))?.replace('状态:', '') || '草稿'),
                          categories: labelNames.filter(l => l.startsWith('分类:')).map(l => l.replace('分类:', '')),
                          displays: labelNames.filter(l => l.startsWith('展示:')).map(l => l.replace('展示:', '')),
                          tags: labelNames.filter(l => !l.includes(':'))
                        };
                      }

                      // 辅助函数：通用区块提取
                      function extractSection(body, headerName) {
                        if (!body) return '';
                        const patterns = [
                          // 增加对“文章内容”区块的特殊处理，允许其内部包含 --- 或 # 标题
                          headerName === '文章内容' 
                            ? new RegExp(`(?:^|[\\r\\n])#+\\s*${headerName}\\s*[\\r\\n]+([\\s\\S]*)`, 'i')
                            : new RegExp(`(?:^|[\\r\\n])#+\\s*${headerName}\\s*[\\r\\n]+([\\s\\S]*?)(?=(?:[\\r\\n](?:#+|---|_+) [A-Z])|$)`, 'i'),
                          new RegExp(`(?:^|[\\r\\n])${headerName}\\s*[\\r\\n]+(?:[-_=]{3,}[\\r\\n]+)?([\\s\\S]*?)(?=(?:[\\r\\n](?:#+|---|_+) [A-Z])|$)`, 'i')
                        ];

                        for (const pattern of patterns) {
                          const match = body.match(pattern);
                          if (match && match[1].trim()) {
                            return match[1].trim();
                          }
                        }
                        return '';
                      }

                      // 辅助函数：提取封面图
                      function extractCoverImage(body) {
                        const section = extractSection(body, '封面图片');
                        const source = section || body;
                        
                        const mdImage = source.match(/!\[[^\]]*]\((https?:\/\/[^\)]+)\)/);
                        if (mdImage) return mdImage[1];
                        
                        const urlMatch = source.match(/https?:\/\/\S+/);
                        if (urlMatch) return urlMatch[0];

                        return 'https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=1200&auto=format&fit=crop';
                      }

                      // 辅助函数：提取摘要
                      function extractDescription(body) {
                        if (!body) return '';
                        
                        // 1. 尝试从摘要区块提取
                        let source = extractSection(body, '摘要');
                        
                        // 2. 如果没有摘要区块，尝试从文章内容提取第一段
                        if (!source) {
                          const content = extractSection(body, '文章内容') || body;
                          source = content
                            .split(/[\r\n]+/)
                            .find(p => p.trim() && !p.startsWith('#') && !p.startsWith('![')) || '';
                        }

                        const text = source
                          .replace(/!\[.*?\]\((https?:\/\/[^\)]+)\)/g, '')
                          .replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1')
                          .replace(/[#>*_`]/g, '')
                          .replace(/\r/g, '')
                          .trim();
                          
                        const sliced = text.substring(0, 200);
                        return sliced + (text.length > 200 ? '...' : '');
                      }

                      function extractContent(body) {
                        return extractSection(body, '文章内容') || body;
                      }

                      // 辅助函数：计算阅读时间
                      function calculateReadTime(body) {
                        if (!body) return '1 分钟';
                        const words = body.length;
                        const minutes = Math.ceil(words / 300);
                        return `${minutes} 分钟阅读`;
                      }

                      // 辅助函数：解析单个 Issue
                      async function parseIssue(issue) {
                        const parsed = parseLabels(issue.labels);
                        
                        const comments = await github.rest.issues.listComments({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          issue_number: issue.number
                        });
                        
                        return {
                          id: issue.id,
                          number: issue.number,
                          title: issue.title,
                          description: extractDescription(issue.body),
                          content: extractContent(issue.body),
                          author: {
                            name: issue.user.login,
                            avatar: issue.user.avatar_url,
                            url: issue.user.html_url
                          },
                          status: parsed.status || '草稿',
                          categories: parsed.categories,
                          tags: parsed.tags,
                          displays: parsed.displays,
                          coverImage: extractCoverImage(issue.body),
                          readTime: calculateReadTime(extractContent(issue.body)),
                          createdAt: issue.created_at,
                          updatedAt: issue.updated_at,
                          commentsCount: comments.data.length,
                          url: issue.html_url
                        };
                      }

                      let articlesData = { articles: [], total: 0, lastUpdate: new Date().toISOString() };

                      if (isFullSync) {
                        console.log('执行全量同步...');
                        
                        const issues = await github.paginate(github.rest.issues.listForRepo, {
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          state: 'open',
                          labels: '状态:已发布',
                          per_page: 100
                        });
                        
                        console.log(`找到 ${issues.length} 篇已发布文章`);
                        
                        for (const issue of issues) {
                          const article = await parseIssue(issue);
                          articlesData.articles.push(article);
                        }
                        
                      } else {
                        console.log('执行增量同步...');
                        
                        if (fs.existsSync(articlesFile)) {
                          articlesData = JSON.parse(fs.readFileSync(articlesFile, 'utf8'));
                        }
                        
                        const issueNumber = context.payload.issue?.number;
                        if (issueNumber) {
                          const issue = await github.rest.issues.get({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            issue_number: issueNumber
                          });
                          
                          const parsed = parseLabels(issue.data.labels);
                          const isPublished = parsed.status === '已发布';
                          console.log(`Issue #${issueNumber} 状态: ${parsed.status}, 是否发布: ${isPublished}`);
                          
                          const existingIndex = articlesData.articles.findIndex(a => a.number === issueNumber);
                          
                          if (isPublished) {
                            const article = await parseIssue(issue.data);
                            
                            if (existingIndex >= 0) {
                              articlesData.articles[existingIndex] = article;
                              console.log(`更新文章 #${issueNumber}: ${article.title}`);
                            } else {
                              articlesData.articles.push(article);
                              console.log(`新增文章 #${issueNumber}: ${article.title}`);
                            }
                          } else {
                            if (existingIndex >= 0) {
                              articlesData.articles.splice(existingIndex, 1);
                              console.log(`删除文章 #${issueNumber}`);
                            }
                          }
                        }
                      }

                      // 按置顶和时间排序
                      articlesData.articles.sort((a, b) => {
                        const aPinned = a.displays.includes('置顶');
                        const bPinned = b.displays.includes('置顶');
                        if (aPinned !== bPinned) return bPinned ? 1 : -1;
                        return new Date(b.updatedAt) - new Date(a.updatedAt);
                      });

                      articlesData.total = articlesData.articles.length;
                      articlesData.lastUpdate = new Date().toISOString();

                      fs.writeFileSync(articlesFile, JSON.stringify(articlesData, null, 2));
                      console.log(`✅ 已保存 ${articlesData.total} 篇文章到 articles.json`);

            - name: Commit and push changes
              if: github.event_name != 'issues' || steps.check_sync.outputs.should_sync == 'true'
              run: |
                  git config user.name "github-actions[bot]"
                  git config user.email "github-actions[bot]@users.noreply.github.com"

                  if [ -f public/data/articles.json ]; then
                    git add public/data/articles.json
                  fi

                  if ! git diff --staged --quiet; then
                    git commit -m "chore: 更新文章数据"
                    
                    # 推送时如果失败则拉取并重试
                    for i in {1..3}; do
                      if git push; then
                        echo "✅ 推送成功"
                        break
                      else
                        echo "⚠️  推送失败，尝试拉取最新代码..."
                        git pull --rebase
                        if [ $i -eq 3 ]; then
                          echo "❌ 推送失败，已重试3次"
                          exit 1
                        fi
                      fi
                    done
                  else
                    echo "没有变更需要提交"
                  fi
